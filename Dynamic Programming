use std::cmp;

fn maximum_coins(mut coins: Vec<Vec<i32>>, k: i32) -> i64 {
    coins.sort_unstable_by_key(|v| v[0]);
    let size = coins.len();
    let mut p: Vec<i64> = vec![0; size + 1];
    
    for i in 0..size {
        p[i + 1] = p[i] + ((coins[i][1] - coins[i][0] + 1) as i64)*(coins[i][2]);
    }
    
    coins.sort_unstable_by_key(|v| v[0]);
    let size = coins.len();
    let mut p: Vec<i64> = vec![0; size + 1];
    
    for i in 0..size {
        p[i + 1] = p[i] + ((coins[i][1] - coins[i][0] + 1) as i64)*(coins[i][2] as i64);
    }
    
    let mut max_coins: i64 = 0;
    
    for i in 0..1 {
        
        if coins[i][1] - coins[i][0] + 1 > k {
            max_coins = cmp::max(max_coins, k as i64 * coins[i][2] as i64);
        } else {
            let mut low: usize = i;
            let mut high: usize = size - 1;
            
            while low <= high {
                let mid = (low + high)/2;
                if coins[mid][0] - coins[i][0] + 1 <= k {
                    if mid == size - 1 {
                        let temp = (cmp::min(coins[i][0] + k - 1, coins[mid][1]) + 1 - coins[mid][0]) as i64 * coins[mid][2] as i64;
                        max_coins = cmp::max(max_coins, temp + p[mid] - p[i]);
                        break
                    } else {
                        if coins[mid + 1][0] - coins[i][0] + 1 <= k {
                            low = mid + 1;
                        } else {
                            let temp = (cmp::min(coins[i][0] + k - 1, coins[mid][1]) + 1 - coins[mid][0]) as i64 * coins[mid][2] as i64;
                            max_coins = cmp::max(max_coins, temp + p[mid] - p[i]);
                            break
                        }
                    }
                } else {
                    high = mid - 1;
                }
            }
        }
        
        let mut low: usize = i;
        let mut high: usize = size - 1;
            
        while low <= high {
            let mid = (low + high)/2;
            if coins[mid][0] - coins[i][1] + 1 <= k {
                if mid == size - 1 {
                    let temp = (cmp::min(coins[i][1] + k - 1, coins[mid][1]) + 1 - coins[mid][0]) as i64 * coins[mid][2] as i64;
                    if coins[i][1] + k - 1 > coins[mid][1] {
                        let d: i64 = cmp::min(coins[i][1] + k - 1 - coins[mid][1], coins[i][1] - coins[i][0]) as i64;
                        max_coins = cmp::max(max_coins, temp + p[mid] - p[i + 1] + (d + 1)*coins[i][2] as i64);
                    } 
                    max_coins = cmp::max(max_coins, temp + p[mid] - p[i + 1] + coins[i][2] as i64);
                    break
                } else {
                    if coins[mid + 1][0] - coins[i][1] + 1 <= k {
                        low = mid + 1;
                    } else {
                        let temp = (cmp::min(coins[i][1] + k - 1, coins[mid][1]) + 1 - coins[mid][0]) as i64 * coins[mid][2] as i64;
                        if coins[i][1] + k - 1 > coins[mid][1] {
                            let d: i64 = cmp::min(coins[i][1] + k - 1 - coins[mid][1], coins[i][1] - coins[i][0]) as i64;
                            max_coins = cmp::max(max_coins, temp + p[mid] - p[i + 1] + (d + 1)*coins[i][2] as i64);
                        }
                        max_coins = cmp::max(max_coins, temp + p[mid] - p[i + 1] + coins[i][2] as i64);
                        break
                    }
                }
            } else {
                high = mid - 1;
            }
        }
    } 
    
    return max_coins
}

//Leetcode 3509
use std::cmp;
use std::collections::BTreeSet;

fn main() {
    let arr: Vec<i32> = vec![10, 10, 9, 5, 6];
    let limit: i32 = 6000;
    let k: i32 = 4;
    let n = arr.len();
    let m: usize = 12*n + 4;
    let l: i32 = 6*n as i32;
    let mut odd_map: Vec<BTreeSet<i32>> = vec![BTreeSet::new(); m];
    let mut even_map: Vec<BTreeSet<i32>> = vec![BTreeSet::new(); m];
    let mut res: i32 = -1;
    
    let mut f: Vec<Vec<Vec<bool>>> = vec![vec![vec![false; m]; 2]; n];
    
    f[0][1][(arr[0] + l) as usize] = true;
    odd_map[(arr[0] + l) as usize].insert(arr[0]);
    if k == arr[0] {
        res = cmp::max(res, arr[0]);
    }
    
    for i in 1..n {
        for t in 0..2 {
            if t == 0 {
                for s in -l..=cmp::min(l, l + 2 - arr[i]) {
                    f[i][0][(s + l) as usize] = f[i - 1][0][(s + l) as usize] || f[i - 1][1][(s + l + arr[i]) as usize];
                    if f[i - 1][1][(s + l + arr[i]) as usize] {
                        let upper: i32 = if arr[i] > 0 {limit/arr[i]} else {i32::MAX};
                        let set_iter = odd_map[(s + l + arr[i]) as usize].iter();
                        for &val in set_iter {
                            if val > upper {
                                break
                            } else {
                                even_map[(s + l) as usize].insert(val*arr[i]);
                                if k == s {
                                    res = cmp::max(res, val*arr[i]);
                                }
                            }
                        }
                    }
                }
            } else {
                for s in cmp::max(-l, arr[i] - l)..=l {
                    f[i][1][(s + l) as usize] =  f[i - 1][1][(s + l) as usize] || f[i - 1][0][(s + l - arr[i]) as usize];
                    if f[i - 1][0][(s + l - arr[i]) as usize] {
                        let upper: i32 = if arr[i] > 0 {limit/arr[i]} else {i32::MAX};
                        let set_iter = even_map[(s + l - arr[i]) as usize].iter();
                        for &val in set_iter {
                            if val > upper {
                                break
                            } else {
                                odd_map[(s + l) as usize].insert(val*arr[i]);
                                if k == s {
                                    res = cmp::max(res, val*arr[i]);
                                }
                            }
                        }
                    }
                }
                f[i][1][(arr[i] + l) as usize] = true;
                odd_map[(arr[i] + l) as usize].insert(arr[i]);
                if k == arr[i] {
                    res = cmp::max(res, arr[i]);
                }
                
            }
        }
    }
    println!("{:?}", even_map[(4 + l) as usize])
    
}


//Leetcode 3490
#[derive(Debug, Clone)]
struct Element {
    arr: [i64; 10],
    curr_idx: i64,
    len: i64
}

fn main() {
    let d: i64 = 9;
    let mut stk: Vec<Element> = Vec::new();
    stk.push(Element{arr: [0; 10], curr_idx: -1, len: 0});
    let mut ans: Vec<Element> = Vec::new();
   
    while !stk.is_empty() {
        let curr = stk.pop().unwrap();
        if curr.curr_idx < 9 {
            for i in 0..=d-curr.len {
                let mut temp = curr.clone();
                temp.arr[(temp.curr_idx + 1) as usize] = i;
                temp.len += i;
                temp.curr_idx += 1;
                if temp.len == d {
                    ans.push(temp);
                } else {
                    stk.push(temp);
                }
            }
        }
    }
    
    let num: Vec<usize> = vec![9, 9, 9, 3, 8, 7, 5, 1, 1];
    let mut f: Vec<i64> = vec![1; d as usize + 1];
    
    for i in 0..d as usize {
        f[i + 1] = (i as i64 + 1)*f[i];
    }
   
    let mut count: i64 = 0;
    for element in &ans {
        let mut sum: i64 = 0;
        let mut prod: i64 = 1;
        let mut fact: i64 = 1;
        for i in 0..10 {
            sum += (i as i64)*element.arr[i];
            if element.arr[i] > 0 {
                prod *= (i as i64).pow(element.arr[i] as u32);
                fact *= f[element.arr[i] as usize];
            }
        }
        if sum > 0 && prod % sum == 0 {
            let mut temp: Element = element.clone();
            for j in 0..num.len() {
                if j > 0 {
                    for i in 0..num[j] {
                        if temp.arr[i] > 0 {
                            count += f[d as usize - j - 1]/(fact/temp.arr[i]);
                        }
                    }
                } else {
                    for i in 1..num[j] {
                        if temp.arr[i] > 0 {
                            count += f[d as usize - j - 1]/(fact/temp.arr[i]);
                        }
                    }
                }
                
                if temp.arr[num[j]] == 0 {
                    break
                }else {
                    fact /= temp.arr[num[j]];
                    temp.arr[num[j]] -= 1;
                }
            }
        }
    }
   
   
    println!("{:?}", count)
}


//Leetcode 446
use std::collections::HashMap;

impl Solution {
    pub fn number_of_arithmetic_slices(nums: Vec<i32>) -> i32 {
        let size = nums.len();
        let mut dp: Vec<HashMap<i64, i32>> = vec![HashMap::new(); size];
        let mut count: i32 = 0;
    
        for j in 1..size {
            for i in 0..j  {
                let diff: i64 = nums[j] as i64 - nums[i] as i64;
                let val = *dp[i].get(&diff).unwrap_or(&0);
                *dp[j].entry(diff).or_insert(0) += val + 1;
                count += val;
            }
        }
    
        return count 
    }
}

//Leetcode 689
impl Solution {
    pub fn max_sum_of_three_subarrays(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let size = nums.len();
        let mut prefix: Vec<i64> = vec![0; size + 1];
    
        for i in 0..size {
            prefix[i + 1] = prefix[i] + nums[i] as i64;
        }
    
        let mut max1: Vec<usize> = vec![0; size];
        max1[k as usize - 1] = k as usize - 1;
        let mut max2: Vec<usize> = vec![0; size];
        max2[2*k as usize - 1] = 2*k as usize - 1;
        let mut val1: i64 = prefix[2*k as usize];
        let mut val2: i64 = prefix[3*k as usize];
        let mut ret: Vec<i32> = vec![0, k, 2*k];
    
        for i in k as usize..size {
            if prefix[i + 1] - prefix[i + 1 - k as usize] > prefix[max1[i - 1] + 1] - prefix[max1[i - 1] + 1 - k as usize] {
                max1[i] = i;
            } else {
                max1[i] = max1[i - 1];
            }
        
            if i > 2*k as usize - 1 {
                if prefix[i + 1] - prefix[i + 1 - k as usize] + prefix[max1[i - k as usize] + 1] - prefix[max1[i - k as usize] + 1 - k as usize] > val1 {
                    val1 = prefix[i + 1] - prefix[i + 1 - k as usize] + prefix[max1[i - k as usize] + 1] - prefix[max1[i - k as usize] + 1 - k as usize];
                    max2[i] = i;
                } else {
                    max2[i] = max2[i - 1];
                }
            }
        
            if i > 3*k as usize - 1 {
                if prefix[i + 1] - prefix[i + 1 - k as usize] + prefix[max2[i - k as usize] + 1] - prefix[max2[i - k as usize] + 1 - k as usize] + prefix[max1[max2[i - k as usize] - k as usize] + 1] - prefix[max1[max2[i - k as usize] - k as usize] + 1 - k as usize] > val2 {
                    val2 = prefix[i + 1] - prefix[i + 1 - k as usize] + prefix[max2[i - k as usize] + 1] - prefix[max2[i - k as usize] + 1 - k as usize] + prefix[max1[max2[i - k as usize] - k as usize] + 1] - prefix[max1[max2[i - k as usize] - k as usize] + 1 - k as usize];
                    ret[0] = (max1[max2[i - k as usize] - k as usize] + 1 - k as usize) as i32;
                    ret[1] = (max2[i - k as usize] + 1 - k as usize) as i32;
                    ret[2] = (i + 1 - k as usize) as i32;
            }
        }
    }
    
    return ret
    }
}

//Leetcode 790
impl Solution {
    pub fn num_tilings(n: i32) -> i32 {
        if n == 1 || n == 2{
            return n
        } else {
            const MOD: i32 = 10_i32.pow(9) + 7;
            let mut dp: Vec<i32> = vec![1;n as usize + 1];
            dp[2] = 2;
            for i in 3..n as usize + 1 {
                let a = 2*dp[i - 1] % MOD;
                let b = dp[i - 3] % MOD;
                dp[i] = (a + b) % MOD;
            }

            return dp[n as usize] % MOD
        }
    }
}

//Leetcode 1186
use std::cmp;

impl Solution {
    pub fn maximum_sum(arr: Vec<i32>) -> i32 {
        let size = arr.len();
        let mut forward: Vec<i64> = vec![0; size + 1];
        let mut backward: Vec<i64> = vec![0; size + 1];
        let mut pre_min: Vec<i64> = vec![0; size + 1];
        let mut suff_min: Vec<i64> = vec![0; size + 1];
        let mut pre_index: usize = 0;
        let mut suff_index: usize = size;
        let mut min: i64 = 0;
    
        let mut neg_list: Vec<usize> = Vec::new();
        let mut ans: i64 = i64::MIN;
    
        for i in 0..size {
            forward[i + 1] = forward[i] + arr[i] as i64;
            backward[size - 1 - i] =  backward[size - i] + arr[size - 1 - i] as i64;
        
            ans = cmp::max(ans, forward[i + 1] - min);
            min = cmp::min(min, forward[i + 1]);
            if forward[i + 1] > forward[pre_index] {
                pre_index = i + 1;
            } 
            if backward[size - 1 - i] > backward[suff_index] {
                suff_index = size - 1 - i;
            }
            pre_min[i + 1] = cmp::min(pre_min[i], forward[i + 1]);
            suff_min[size - 1 - i] = cmp::min(suff_min[size - i], backward[size - 1 - i]);
        
            if arr[i] < 0 {
                neg_list.push(i)
            }
        }
    
        for index in neg_list {
            if index == 0  {
                if pre_index != 0 {
                    ans = cmp::max(ans, forward[pre_index] - arr[index] as i64);
                }
            } else if index == size - 1 {
                if suff_index != size {
                    ans = cmp::max(ans, backward[index + 1] - arr[index] as i64);
                }
            } else {
                ans = cmp::max(ans, forward[index] - pre_min[index - 1] + (backward[index + 1] - suff_min[index + 1]));
            }
        }
    
        return ans as i32
    }
}

//Leetcode 2830
use std::cmp;
use std::collections::HashMap;

impl Solution {
    pub fn maximize_the_profit(n: i32, mut offers: Vec<Vec<i32>>) -> i32 {
        let mut map: HashMap<i32, Vec<i32>> = HashMap::new();
        let mut gold: HashMap<(i32, i32), i32> = HashMap::new();

        offers.sort_unstable_by_key(|v| v[2]);

        for idx in 0..offers.len() {
            map.entry(offers[idx][1]).and_modify(|v| v.push(offers[idx][0])).or_insert(vec![offers[idx][0]]);
            gold.insert((offers[idx][0], offers[idx][1]), offers[idx][2]);
        }
    
        let mut dp: Vec<i32> = vec![0; n as usize];
    
        for idx in 0..n {
            if map.contains_key(&idx) {
                let vec: Vec<i32> = map.get(&idx).unwrap().clone();
                for i in 0..vec.len() {
                    if vec[i] == 0 {
                        if idx == 0 {
                            dp[idx as usize] = cmp::max(dp[idx as usize], *gold.get(&(vec[i], idx)).unwrap());
                        } else {
                            dp[idx as usize] = cmp::max(dp[idx as usize - 1], cmp::max(dp[idx as usize], *gold.get(&(vec[i], idx)).unwrap()));
                        }
                    } else {
                        dp[idx as usize] = cmp::max(dp[idx as usize - 1], cmp::max(dp[idx as usize], dp[vec[i] as usize - 1] + *gold.get(&(vec[i], idx)).unwrap()));
                    }
                }
            } else {
                if idx > 0 {
                    dp[idx as usize] = dp[idx as usize - 1];
                }
            }
        }
    
        return dp[n as usize - 1]
    }
}

//Leetcode 3082
impl Solution {
    pub fn sum_of_power(mut nums: Vec<i32>, k: i32) -> i32 {
        const MOD: i64 = 10_i64.pow(9) + 7;
        let size = nums.len();
        let mut power: Vec<i64> = vec![1; size];
        let mut dp: Vec<Vec<i64>> = vec![vec![0; k as usize + 1]; size];
    
        for i in 1..size {
            power[i] = power[i - 1] * 2;
            power[i] %= MOD;
        }
     
        nums.sort_unstable();
    
        for i in 0..size {
            for j in 1..k as usize + 1 {
                if i == 0 {
                    if nums[i] == j as i32 {
                        dp[i][j] = 1;
                    }
                } else {
                    dp[i][j] = 2*dp[i - 1][j];
                    dp[i][j] %= MOD;
                    if nums[i] < j as i32 {
                        dp[i][j] += dp[i - 1][j - nums[i] as usize];
                    } else if nums[i] == j as i32 {
                        dp[i][j] += power[i];
                    }
                    dp[i][j] %= MOD;
                }
            }
        }
    
        let mut res = dp[size - 1][k as usize];
        while res < 0 {
            res += MOD;
        }
    
        return (res % MOD) as i32
    }
}
